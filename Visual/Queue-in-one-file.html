<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Queue</title>
    <link rel = 'stylesheet' href = 'Queue.css' type = 'text/css'>
    <script>
        window.onload = function() {
            ChangeAnimating();
            ChangePushIncrement();
        }
        var colors = [["#007fff", "#3fbfff", "#006f6f"],
                        ["#ff7f00", "#ffbf3f", "#6f6f00"],
                        ["#7fff00", "#9fdf3f", "#006f00"],
                        ["#ff007f", "#ff7f7f", "6f0000]"]];

        var isAnimating = true;
        var pushIncrementing;
        var TimeoutId;

        var Timer = {
            animation : 1000,
            datetime : Date.now(),
            set animationTime(value) {
                this.animation = value;
                document.styleSheets[0].cssRules[13].style.animation = value + "ms ease 0s 1 normal none running push";
                document.styleSheets[0].cssRules[14].style.animation = value + "ms ease 0s 1 normal none running pop";
            },
            get time() {
                let result = this.datetime - Date.now() + this.animation;
                this.datetime += (result < 0 ? this.animation - result : this.animation)
                return result;
            }
        };

        class PStack
        {
            constructor(previous, value, color)
            {
                this.previous = previous;
                this.value = value;
                this.size = (previous ? previous.size + 1 : 0);
                this.color = (color != undefined ? color : Math.floor(Math.random() * 4) % 4);
            }

            Push(value, color)
            {
                return new PStack(this, value, color);
            }

            Pop()
            {
                return this.previous;
            }
        };

        class PQueue
        {
            constructor(leftReserve, left, right, mediate,
                rightCopyReserve, rightCopy,
                recopy, toCopy, rightCopied)
            {
                this.leftReserve = (leftReserve ? leftReserve : new PStack());
                this.left = (left ? left : new PStack());
                this.right = (right ? right : new PStack());
                this.mediate = (mediate ? mediate : new PStack());
                this.rightCopyReserve = (rightCopyReserve ? rightCopyReserve : new PStack());
                this.rightCopy = (rightCopy ? rightCopy : new PStack());

                this.recopy = (recopy != undefined ? recopy : false);
                this.toCopy = (toCopy != undefined ? toCopy : 0);
                this.rightCopied = (rightCopied != undefined ? rightCopied : false);
            }

            Push(value)
            {
                let time = Timer.time;

                let newLeftReserve = this.leftReserve;
                let newLeft = this.left;
                let newRightCopyReserve = this.rightCopyReserve;
                let newRecopy = this.recopy;

                if (newRecopy)
                {
                    newLeftReserve = newLeftReserve.Push(value);
                    ReservePush(time, newLeftReserve);
                }
                else
                {
                    newLeft = newLeft.Push(value);
                    NormalPush(time, newLeft, newRightCopyReserve.size);
                    newRecopy = newLeft.size > this.right.size;
                    if (newRightCopyReserve.size)
                    {
                        newRightCopyReserve = newRightCopyReserve.Pop();
                    }
                }
                let newQueue = new PQueue(newLeftReserve, newLeft, this.right, this.mediate,
                    newRightCopyReserve, this.rightCopy, newRecopy, this.toCopy, this.rightCopied);

                if(!newRecopy)
                {
                    TimeoutId = setTimeout(PrintVersion, time, queueIndex + 1, "Додано елемент \"" + value + "\"", 0);
                }
                return (newRecopy ? newQueue.Recopy(true, value) : newQueue);
            }

            Pop()
            {
                let time = Timer.time;

                let newRight = this.right;
                let newRightCopyReserve = this.rightCopyReserve;
                let newRightCopy = this.rightCopy;
                let newToCopy = this.toCopy;
                let newRecopy = this.recopy;
                let value = this.Get();

                if (newRecopy)
                {
                    if (newToCopy > 0)
                    {
                        newToCopy = newToCopy - 1;
                        RecopyPop(time);
                    }
                    else
                    {
                        newRight = newRight.Pop();
                        newRightCopyReserve = newRightCopyReserve.Pop();
                        RecopyExtendedPop(time);
                    }
                }
                else
                {
                    newRight = newRight.Pop();
                    NormalPop(time, newRightCopyReserve.size);
                    if (this.left.size > newRight.size)
                    {
                        newRecopy = true;
                    }
                    if (newRightCopyReserve.size)
                    {
                        newRightCopyReserve = newRightCopyReserve.Pop();
                    }
                }

                newRightCopy = newRightCopy.Pop();
                let newQueue = new PQueue(this.leftReserve, this.left, newRight, this.mediate,
                    newRightCopyReserve, newRightCopy, newRecopy, newToCopy, this.rightCopied);

                if(!newRecopy)
                {
                    TimeoutId = setTimeout(PrintVersion, time, queueIndex + 1, "Взято елемент \"" + value + "\"", 0);
                }

                return (newRecopy ? newQueue.Recopy(false, value) : newQueue);
            }

            Get()
            {
                return (this.recopy
                    ? this.rightCopy.value
                    : this.right.value);
            }

            Recopy(isPush, value)
            {
                let newLeft = this.left;
                let newRight = this.right;
                let newMediate = this.mediate;
                let newRightCopyReserve = this.rightCopyReserve;
                let newRightCopied = this.rightCopied;
                let newToCopy = this.toCopy;

                let actions = 3;
                while (!newRightCopied && newRight.size && actions)
                {
                    let time = Timer.time;
                    RightToMediate(time, newRight);

                    newMediate = newMediate.Push(newRight.value, newRight.color);
                    newRight = newRight.Pop();
                    ++newToCopy;
                    --actions;
                }

                while (newLeft.size && actions)
                {
                    let time = Timer.time;
                    LeftToRight(time, newLeft);

                    newRightCopied = true;
                    newRight = newRight.Push(newLeft.value, newLeft.color);
                    newRightCopyReserve = newRightCopyReserve.Push(newLeft.value, newLeft.color);
                    newLeft = newLeft.Pop();
                    --actions;
                }

                while (newToCopy > 0 && actions)
                {
                    let time = Timer.time;
                    MediateToRight(time, newMediate);

                    newRight = newRight.Push(newMediate.value, newMediate.color);
                    newRightCopyReserve = newRightCopyReserve.Push(newMediate.value, newMediate.color);
                    newMediate = newMediate.Pop();
                    --newToCopy;
                    --actions;
                }

                while (newMediate.size && actions)
                {
                    let time = Timer.time;
                    CleanMediate(time);

                    newMediate = newMediate.Pop();
                    --actions;
                }

                let time = Timer.time;
                TimeoutId = setTimeout(PrintVersion, time, queueIndex + 1, (isPush ? "Додано" : "Взято") + " елемент \"" + value + "\" з перекопіюванням", 0);

                if (actions)
                {
                    TimeoutId = setTimeout(SwapStacks, time, true);
                    let text = GetRecopyText(4);
                    TimeoutId = setTimeout(SetNotify, time, text);

                    time = Timer.time;
                    TimeoutId = setTimeout(SwapStacks, time, false);

                    return new PQueue(newLeft, this.leftReserve, newRight, newMediate,
                        this.rightCopy, newRightCopyReserve, false, 0, false);
                }
                
                return new PQueue(this.leftReserve, newLeft, newRight, newMediate,
                    newRightCopyReserve, this.rightCopy, true, newToCopy, newRightCopied);
            }
        };

        queues = new Array();
        queues[0] = new PQueue();
        queueIndex = 0;
        elementIds = 1;

        var datetime = Date.now();

        function Push(value)
        {
            if (value != undefined) {
                queueIndex = queues.push(queues[queueIndex].Push(value)) - 1;
            }
            else {
                queueIndex = queues.push(queues[queueIndex].Push(pushInput.value)) - 1;
                if (pushIncrementing) {
                    pushInput.value++;
                }
                pushInput.focus();
            }
            //VisualQueue(queueIndex);
        }

        function Pop()
        {
            popOutput.value = queues[queueIndex].Get();
            queueIndex = queues.push(queues[queueIndex].Pop()) - 1;
            //VisualQueue(queueIndex);
        }

        function VisualQueue(index)
        {
            queueIndex = index;
            CleanChilds(LeftReserve);
            CleanChilds(Left);
            CleanChilds(Right);
            CleanChilds(Mediate);
            CleanChilds(RightCopyReserve);
            CleanChilds(RightCopy);

            let queue = queues[index];

            FillStack(queue.leftReserve, LeftReserve);
            FillStack(queue.left, Left);
            FillStack(queue.right, Right);
            FillStack(queue.mediate, Mediate);
            FillStack(queue.rightCopyReserve, RightCopyReserve);
            FillStack(queue.rightCopy, RightCopy);
        }

        function FillStack(stack, DOMElement)
        {
            let elements = new PStack();
            while(stack.size)
            {
                let div = document.createElement('div');
                div.className = "element";
                div.innerText = stack.value;
                div.style.border = "3px solid " + colors[stack.color][0];
                div.style.backgroundColor = colors[stack.color][1];
                div.style.color = colors[stack.color][2];
                stack = stack.previous;
                elements = elements.Push(div);
            }
            while(elements.size)
            {
                DOMElement.appendChild(elements.value);
                elements = elements.previous;
            }
        }

        function CleanChilds(DOMElement)
        {
            while (DOMElement.firstChild) {
                DOMElement.removeChild(DOMElement.firstChild);
            }
        }

        function AddElement(DOMElement, value, color)
        {
            let div = document.createElement('div');
            div.className = "element addElement";
            div.innerText = value;
            div.style.borderColor = colors[color][0];
            div.style.backgroundColor = colors[color][1];
            div.style.color = colors[color][2];
            document.getElementById(DOMElement).appendChild(div);
            //setTimeout(SetStandart, 1800, div);
        }

        function MarkDeleteElement(DOMElement)
        {
            document.getElementById(DOMElement).lastChild.className = "element deleteElement";
        }

        function RemoveElement(time, DOMElement) {
            TimeoutId = setTimeout(MarkDeleteElement, time - 10, DOMElement);
            TimeoutId = setTimeout(DeleteElement, time + Timer.animation - 20, DOMElement);
        }

        function DeleteElement(DOMElement)
        {
            document.getElementById(DOMElement).removeChild(document.getElementById(DOMElement).lastChild);
        }

        function SetStandart(element)
        {
            element.className = "element";
        }

        function SetTime()
        {
            let time = Number(timeInput.value);
            if (time >= 50) {
                Timer.animationTime = time;
            }
        }

        function PrintVersion(queueID, text, level)
        {
            if (level == 0) {
                let button = document.createElement('button');
                button.className = "logVersion";
                button.onclick = function() {
                    VisualQueue(queueID)
                };
                button.innerHTML = text;
                log.appendChild(button);
            }
            else{
                let p = document.createElement('p');
                p.className = "logRecord";
                log.appendChild(p);
            }
        }

        function ReadFile(inputElement)
        {
            filename = inputElement.files[0];
            if (filename) {
                let fileReader = new FileReader();
                fileReader.onload = function(e) {
                    DoActions(e.target.result);
                }
                fileReader.readAsText(filename);
            }
            else
            {
                alert("Access denied!");
            }
        }
        function DoActions(actionsString) {
            let actions = actionsString.split(/[\r\n]/);
            for (let index = 0; index < actions.length; index++) {
                const element = actions[index];
                let parts = element.split(/[\t ]/, 2);
                if (parts[0] == "push" && parts[1] != undefined && parts[1].length < 10) {
                    Push(parts[1]);
                }
                else if (parts[0] == "pop") {
                    Pop();
                }
                else if(parts[0] == "time" && parts[1] >= 50)
                {
                    Timer.animationTime = Number(parts[1]);
                }
            }
        }

        function SetNotify(text) {
            stage.innerHTML = text;
        }

        function ReservePush(time, element) {
            let text = "Режим перекопіювання.</br>Елемент додано до резервного лівого стеку.";
            TimeoutId = setTimeout(AddElement, time, "LeftReserve", element.value, element.color);
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function NormalPush(time, element, cleaned) {
            TimeoutId = setTimeout(AddElement, time, "Left", element.value, element.color);
            let text = "Звичайний режим.</br>Елементи додаються до лівого стеку.";
            if (cleaned) {
                RemoveElement(time, "RightCopyReserve");
                text += "</br>Прибираються зайві елементи з резервного правого стеку.";
            }
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function RecopyExtendedPop(time) {

            RemoveElement(time, "Right");
            RemoveElement(time, "RightCopyReserve");
            RemoveElement(time, "RightCopy");
            let text = "Режим перекопіювання.</br>Якщо посередній стек не містить елементів черги, то елементи беруться з трьох стеків, що їх містять:</br>1) правого;</br>2) копії правого;3) резервного правого.";
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function RecopyPop(time) {
            RemoveElement(time, "RightCopy");
            let text = "Режим перекопіювання.</br>Елементи беруться з копії правого стеку";
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function NormalPop(time, cleaned) {
            RemoveElement(time, "Right");
            RemoveElement(time, "RightCopy");
            let text = "Звичайний режим.</br>Елементи беруться з копії правого стеку";
            if (cleaned) {
                RemoveElement(time, "RightCopyReserve");
                text += "</br>Прибираються зайві елементи з резервного правого стеку.";
            }
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function RightToMediate(time, element) {
            TimeoutId = setTimeout(AddElement, time, "Mediate", element.value, element.color);
            RemoveElement(time, "Right");
            let text = GetRecopyText(0);
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function LeftToRight(time, element) {
            TimeoutId = setTimeout(AddElement, time, "Right", element.value, element.color);
            TimeoutId = setTimeout(AddElement, time, "RightCopyReserve", element.value, element.color);
            RemoveElement(time - 20, "Left");
            let text = GetRecopyText(1);
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function MediateToRight(time, element) {
            TimeoutId = setTimeout(AddElement, time, "Right", element.value, element.color);
            TimeoutId = setTimeout(AddElement, time, "RightCopyReserve", element.value, element.color);
            RemoveElement(time, "Mediate");
            let text = GetRecopyText(2);
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function CleanMediate(time) {
            RemoveElement(time, "Mediate");
            let text = GetRecopyText(3);
            TimeoutId = setTimeout(SetNotify, time, text);
        }

        function SwapStacks(first)
        {
            if (first) {
                let LRParent = LeftReserve.parentElement;
                Left.parentElement.appendChild(LeftReserve, Left.parentElement.firstChild);
                LRParent.appendChild(Left, LRParent.firstChild);
                Left.id = "LeftR";
                LeftReserve.id = "Left";
                LeftR.id = "LeftReserve"
                let text = GetRecopyText(5);
            }
            else {
                let RCParent = RightCopy.parentElement;
                RightCopyReserve.parentElement.appendChild(RightCopy, RightCopyReserve);
                RCParent.appendChild(RightCopyReserve, RCParent.firstChild);
                RightCopy.id = "RightCopyR";
                RightCopyReserve.id = "RightCopy";
                RightCopyR.id = "RightCopyReserve";
                stage.innerHTML = "Звичайний режим";
            }
        }

        function ChangeAnimating()
        {
            if (isAnimatingInput.checked) {
                Timer.animationTime = Number(timeInput.value);
            }
            else {
                Timer.datetime = Date.now();
                Timer.animationTime = 0;
                for (let index = 0; index <= TimeoutId; index++) {
                    clearTimeout(index);
                }
                VisualQueue(queueIndex);
                PrintVersion(queueIndex, "Миттєве закінчення анімації", 0);
            }
        }

        function ChangePushIncrement()
        {
            pushIncrementing = pushIncrement.checked;
        }

        function GetRecopyText(stageId) {
            return "<p>Режим перекопіювання. Здійснення перекопіювання:</p>"
                + "<p class=\"" + (stageId < 0 ? "stageUndone\">" : (stageId == 0 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "З правого до посереднього</p>"
                + "<p class=\"" + (stageId < 1 ? "stageUndone\">" : (stageId == 1 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "З лівого до правого та резервного правого</p>"
                + "<p class=\"" + (stageId < 2 ? "stageUndone\">" : (stageId == 2 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "З посереднього до правого та резервного правого</p>"
                + "<p class=\"" + (stageId < 3 ? "stageUndone\">" : (stageId == 3 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "Очищення посереднього від взятих елементів</p>"
                + "<p class=\"" + (stageId < 4 ? "stageUndone\">" : (stageId == 4 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "Обмін лівого з лівим резервним</p>"
                + "<p class=\"" + (stageId < 5 ? "stageUndone\">" : (stageId == 5 ? "stageInProgress\">► " : "stageComplete\">✓ ")) + "Обмін копії правого з правим резервним</p>";
        }

    </script>
</head>
<body>
    <style>
        *{
            margin: 0px;
            padding: 0px;
            font-size: 20px;
            color: #ffffff;
        }
        body{
            display: flex;
            flex-direction: row;
            position: absolute;
            height: 100%;
            width: 100%;
            box-sizing: content-box;
        }
        .visual{
            flex-basis: 100%;
            width: 100%;
            height: 100%;
            background-color: #3f3f3f;
        }
        .management{
            display: flex;
            flex-flow: column;
            height: 100%;
            background-color: #4f4f4f;
            border-left: 3px solid #ffffff;
        }
        .area{
            overflow-y: auto;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .label {
            flex: 1 0 auto;
        }
        .areaWindow{
            display: flex;
            width: 100%;
            flex-shrink: 0;
        }
        .stack{
            width: 100%;
            height: 100%;
            margin-top: auto;
            transform: rotate(180deg);
        }
        .stackContainer{
            width: 100%;
            height: 100%;
        }
        .element{
            border: 3px solid #ff7f00;
            background-color: #ffbf3f;
            color: #bf0000;
            line-height: 50px;
            text-align: center;
            width: 100px;
            height: 50px;
            margin: auto;
            transform: rotate(180deg);
        }
        .stackName{
            color: #ffffff;
            text-align: center;
            border: 4px solid #ffffff;
            width: 100%;
            height: 75px;
            transform: rotate(180deg);
        }
        @keyframes pop{
            from {}
            to {width: 0px; height: 0px; line-height: 0px; font-size: 0px;}
        }
        @keyframes push{
            from {width: 0px; height: 0px; line-height: 0px; font-size: 0px;}
            to {}
        }
        .addElement{
            animation: push 1s;
        }
        .deleteElement{
            animation: pop 1s;
        }
        .menuElement{
            border: 3px solid #ff7f00;
            background-color: #ffbf3f;
            color: #bf0000;
            line-height: 50px;
            text-align: center;
            width: 100px;
            height: 50px;
        }
        .menuElement input{
            width: 100%;
            background-color: #00000000;
            text-align: center;
            line-height: 50px;
            border: 0px;
            color: #bf0000;
        }
        .menuItem button{
            cursor: pointer;
            width: 100px;
            height: 50px;
            box-sizing: content-box;
            color: black;
        }
        .menuItem{
            display: flex;
            width: 100%;
            align-items: center;
            vertical-align: middle;
        }
        .menuItem input{
            width: 100px;
            height: 30px;
            background-color: #ffffff3f;
            text-align: center;
            border: 0px;
        }
        .actionLog{
            overflow-y: scroll;
        }
        .actionsLogWindow{
            display: flex;
            flex-direction: column;
            background-color: #6f6f6f;
            width: 100%;
            transform: rotate(180deg);
        }
        .logVersion{
            cursor: pointer;
            width: 100%;
            background-color: #00000000;
            font-size: 100%;
            color: #4fdf4f;
            transform: rotate(180deg);
            border: 2px solid #4fdf4f;
            margin-top: 2px;
        }
        .logRecord{
            font-size: 75%;
            transform: rotate(180deg);
        }
        h3{
            margin: 5px;
            margin-top: 20px;
            text-align: center;
            border-top: 3px solid #ffffff;
        }
        .notify {
            text-align: center;
            width: 100%;
        }
        .stageComplete {
            color: #4fdf4f;
        }
        .stageInProgress {
            color: #cfcf4f;
        }
        .stageUndone {
            color: #cf4f4f;
        }
    </style>
    <div class="visual">
        <div class="area">
            <div class="label">
                <div class="notify" id="stage">
    
                </div>
            </div>
            <div class="areaWindow">
                <div class="stack">
                    <div class="stackName">
                        Left reserve
                    </div>
                    <div class="stackContainer" id="LeftReserve">
                    </div>
                </div>
                <div class="stack">
                    <div class="stackName">
                        Left
                    </div>
                    <div class="stackContainer" id="Left">
                    </div>
                </div>
                <div class="stack">
                    <div class="stackName">
                        Right
                    </div>
                    <div class="stackContainer" id="Right">
                    </div>
                </div>
                <div class="stack">
                    <div class="stackName">
                        Mediate
                    </div>
                    <div class="stackContainer" id="Mediate">
                    </div>
                </div>
                <div class="stack">
                    <div class="stackName">
                        Right copy reserve
                    </div>
                    <div class="stackContainer" id="RightCopyReserve">
                    </div>
                </div>
                <div class="stack">
                    <div class="stackName">
                        Right copy
                    </div>
                    <div class="stackContainer" id="RightCopy">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="management">
        <h3>Управління елементами</h3>
        <div class="menuItem">
            <button onclick="Push()" style="background-color: #4fcf4f; color: green; border: 4px solid green;">◄Push</button>
            <div class="menuElement">
                <input type="number" id="pushInput" value="1">
            </div>
            <input type="checkbox" id="pushIncrement" onchange="ChangePushIncrement()" style="width: 20px;" checked="true">++
        </div>
        <div class="menuItem">
            <button onclick="Pop()" style="background-color: #cf4f4f; color: #7f0000; border: 4px solid #7f0000;">Pop►</button>
            <div class="menuElement">
                <input type="number" id="popOutput">
            </div>
        </div>
        <div class="menuItem">
            Відкрити файл: 
            <input type="file" id="fileInput" oninput="ReadFile(this)">
        </div>
        <h3>Управління анімацією</h3>
        <div class="menuItem">
            <input type="checkbox" id="isAnimatingInput" style="margin-right: -30px" checked="true" onchange="ChangeAnimating()">Анімація
        </div>
        <div class="menuItem">
            Затримка: 
            <input type="number" id="timeInput" value="1000" min="50" oninput="SetTime()"><p> мс</p>
            <button>Задати</button>
        </div>
        <h3>Лог (історія версій)</h3>
        <div class="actionLog">
            <div class="actionsLogWindow" id="log">
                <button class="logVersion" onclick="VisualQueue(0);">Початкова черга</button>
            </div>
        </div>
    </div>
</body>
</html>